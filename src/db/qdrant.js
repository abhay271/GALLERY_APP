/**
 * Qdrant Vector Database Client
 * 
 * This module handles connection to Qdrant vector database and provides
 * methods for storing and searching image embeddings generated by Azure OpenAI.
 * 
 * Setup Instructions:
 * 1. Install Qdrant locally using Docker:
 *    docker run -p 6333:6333 qdrant/qdrant
 * 
 * 2. Or download native binary from:
 *    https://github.com/qdrant/qdrant/releases
 * 
 * 3. Configure environment variables in .env file:
 *    QDRANT_HOST=localhost
 *    QDRANT_PORT=6333
 *    QDRANT_COLLECTION=gallery_images
 */

const { QdrantClient } = require('@qdrant/qdrant-js');
require('dotenv').config();

class QdrantService {
    constructor() {
        // Initialize Qdrant client with configuration from environment
        this.client = new QdrantClient({
            host: process.env.QDRANT_HOST || 'localhost',
            port: process.env.QDRANT_PORT || 6333,
        });
        
        this.collectionName = process.env.QDRANT_COLLECTION || 'gallery_images';
        this.vectorSize = 1536; // Standard size for text-embedding-ada-002 (Azure OpenAI default)
    }

    /**
     * Initialize the collection if it doesn't exist
     * This should be called once when the application starts
     */
    async initializeCollection() {
        try {
            // Check if collection exists
            const collections = await this.client.getCollections();
            const collectionExists = collections.collections.some(
                collection => collection.name === this.collectionName
            );

            if (!collectionExists) {
                console.log(`Creating collection: ${this.collectionName}`);
                
                // Create collection with vector configuration
                await this.client.createCollection(this.collectionName, {
                    vectors: {
                        size: this.vectorSize,
                        distance: 'Cosine', // Using cosine similarity for text embeddings
                    },
                });
                
                console.log(`Collection ${this.collectionName} created successfully`);
            } else {
                console.log(`Collection ${this.collectionName} already exists`);
            }
        } catch (error) {
            console.error('Error initializing Qdrant collection:', error);
            throw error;
        }
    }

    /**
     * Store image metadata and embedding in Qdrant
     * @param {Object} imageData - Image metadata and embedding
     * @param {string} imageData.filename - Original filename
     * @param {string} imageData.description - AI-generated description
     * @param {Array<number>} imageData.embedding - Text embedding vector
     * @param {string} imageData.timestamp - Upload timestamp
     * @returns {Promise<string>} - Point ID in Qdrant
     */
    async storeImageEmbedding(imageData) {
        try {
            const pointId = Date.now().toString(); // Simple ID generation
            
            const point = {
                id: pointId,
                vector: imageData.embedding,
                payload: {
                    filename: imageData.filename,
                    description: imageData.description,
                    timestamp: imageData.timestamp,
                    uploadDate: new Date().toISOString(),
                }
            };

            await this.client.upsert(this.collectionName, {
                wait: true,
                points: [point]
            });

            console.log(`Stored embedding for image: ${imageData.filename}`);
            return pointId;
        } catch (error) {
            console.error('Error storing image embedding:', error);
            throw error;
        }
    }

    /**
     * Search for similar images based on query embedding
     * @param {Array<number>} queryEmbedding - Query text embedding
     * @param {number} limit - Number of results to return (default: 10)
     * @param {number} scoreThreshold - Minimum similarity score (default: 0.7)
     * @returns {Promise<Array>} - Array of matching image metadata
     */
    async searchSimilarImages(queryEmbedding, limit = 10, scoreThreshold = 0.7) {
        try {
            const searchResult = await this.client.search(this.collectionName, {
                vector: queryEmbedding,
                limit: limit,
                score_threshold: scoreThreshold,
                with_payload: true,
            });

            // Format results for easier consumption
            const results = searchResult.map(hit => ({
                id: hit.id,
                score: hit.score,
                filename: hit.payload.filename,
                description: hit.payload.description,
                timestamp: hit.payload.timestamp,
                uploadDate: hit.payload.uploadDate,
            }));

            console.log(`Found ${results.length} similar images`);
            return results;
        } catch (error) {
            console.error('Error searching similar images:', error);
            throw error;
        }
    }

    /**
     * Get collection info for debugging/monitoring
     */
    async getCollectionInfo() {
        try {
            const info = await this.client.getCollection(this.collectionName);
            return info;
        } catch (error) {
            console.error('Error getting collection info:', error);
            throw error;
        }
    }

    /**
     * Delete a point by ID (for cleanup if needed)
     */
    async deletePoint(pointId) {
        try {
            await this.client.delete(this.collectionName, {
                wait: true,
                points: [pointId]
            });
            console.log(`Deleted point: ${pointId}`);
        } catch (error) {
            console.error('Error deleting point:', error);
            throw error;
        }
    }
}

module.exports = new QdrantService();
